"""
    Dependencies:
    - requests
    - Pillow (PIL)
    - numpy
    - scipy
    - click

    methods:
    - bw
        - spectators will be placed in black areas. supports greyscale for dithering (average color value used: random() >= avg_color).
    - heightmap
        - spectators will be placed according to random() >= blue. the height is hm_max_height * red.
"""

import math
import sys
import io
from typing import Tuple

import requests
from PIL import Image
import numpy as np
from scipy.spatial.transform import Rotation as R
import click


@click.group()
def cli():
    pass

METHODS = [
    "bw",
    "heightmap",
]

@cli.command()
@click.option('--method', type=click.Choice(METHODS, False), default="bw")
@click.option('--facing-dir', type=click.Choice(['nochange', 'towards', 'awayfrom', 'direction'], False), default="nochange")
@click.option('--facing-point', nargs=2, type=float, help="X Y in range (-1,1). Top Left: `-1 -1`, Bottom Right: `1 1`, Top Right: `1 -1`")
@click.option('--block-width', type=float, required=True, help="Width (X) of the output area in game distance units. Depth (Z) will be adjusted according to the image.")
@click.option('--hm-max-height', type=float, required=True, help="Heightmap only: maximum height (Y) of the output area in game distance units.")
@click.option('--exported-file', type=str, default='Export.csv', help='The Export.csv file generated by E++')
@click.option('--output-file', type=str, default='Import.csv', help='The Import.csv file to be imported using E++')
@click.option('--spectator-limit', type=int, default=-1, help="Limit spectators to this amount. -1 to replace all spectators in input file.")
@click.argument('image_url')
def from_image(method, facing_dir, facing_point, block_width, hm_max_height, exported_file, output_file, spectator_limit, image_url: str):
    print([method, facing_dir, facing_point, block_width, image_url])
    image_bs = get_image_bs(image_url)
    img = get_image(image_bs)
    click.echo(f"Image: {img.size}")
    img_arr = np.array(img)
    gen_spectators(img, img_arr, method, facing_dir, facing_point, block_width, hm_max_height, exported_file, output_file, spectator_limit)



def gen_spectators(img, img_arr, method, facing_dir, facing_point, block_width, hm_max_height, exported_file, output_file, spectator_limit):
    spectators = read_export_file(exported_file)[:spectator_limit]
    nb_specs = len(spectators)
    log_each = nb_specs // 10
    for i, spec in enumerate(spectators):
        # spec[4:7] are x,y,z coords
        # y
        x, y, z, u, v = pick_random_point_from_img(img, img_arr, method, block_width, hm_max_height)
        spec[4] = x
        spec[5] = y
        spec[6] = z
        # spec[0:4] are qx, qy, qz, qw
        q = calc_spectator_direction(facing_dir, facing_point, (u, v), spec[:4])
        # print(q)
        qx, qy, qz, qw = q
        spec[0] = qx
        spec[1] = qy
        spec[2] = qz
        spec[3] = qw

        if i % log_each == 0:
            print(f"Progress: {i / nb_specs * 100} %")
    write_import_csv(spectators, output_file)


def calc_spectator_direction(facing_dir, facing_point, uv, orig_q) -> Tuple[float, float, float, float]:
    # choices = 'nochange', 'towards', 'awayfrom', 'direction'
    return calc_s_dir[facing_dir](facing_point, uv, orig_q)

def calc_s_dir_nochange(facing_point, uv, orig_q):
    return orig_q

def calc_s_dir_towards(facing_point, uv, orig_q, theat_offset_radians=0):
    px, pz = facing_point
    # convert (0,1) to (-1,1)
    u = uv[0] * 2. - 1
    v = uv[1] * 2. - 1
    ray_x, ray_z = px - u, pz - v
    return raydir_to_quat(ray_x, ray_z, theat_offset_radians)

def raydir_to_quat(ray_x, ray_z, theta_offset=0):
    # theta = np.arctan2(ray_z, ray_x)
    theta = np.arctan2(ray_x, ray_z)
    # print(theta)
    # r = R.from_rotvec([0, -1, 0], theta + theta_offset)
    r = R.from_euler('x', math.pi) * R.from_euler('y', theta + theta_offset)
    return r.as_quat()

def calc_s_dir_awayfrom(*args):
    return calc_s_dir_towards(*args, theat_offset_radians=math.pi)

def calc_s_dir_direction(facing_point, uv, orig_q):
    ray_x, ray_z = facing_point
    return raydir_to_quat(ray_x, ray_z)

calc_s_dir = {
    'nochange': calc_s_dir_nochange,
    'towards': calc_s_dir_towards,
    'awayfrom': calc_s_dir_awayfrom,
    'direction': calc_s_dir_direction,
}

def pick_random_point_from_img(img: Image.Image, img_arr: np.array, method, block_width, hm_max_height):
    ix, iz = img.size
    # block_height = block_width / ix * iz

    hit = False
    pos = None
    uv = None
    while not hit:
        rx = np.random.random()
        rz = np.random.random()
        u = round((ix - 1) * rx)
        v = round((iz - 1) * rz)
        ui = int(u)
        vi = int(v)
        pixel = list(map(lambda v: float(v)/255., img_arr[vi][ui]))
        # print(f"{pixel}")
        hit = check_hit[method](*pixel)
        uv = (u / ix, v / iz)
        if hit:
            pos = px_to_pos[method](ix, iz, uv, block_width, hm_max_height, *pixel)
            # return (rx * (u / ix * -2. + 1.), rz * (v / iz * -2. + 1.))
    x,y,z = pos
    u,v = uv
    return x,y,z,u,v

def check_hit_bw(r, g, b, a=1.0):
    return np.random.random() >= (r+g+b) / 3.

def check_hit_heightmap(r, g, b, a=1.0):
    '''b channel for probability, r for height'''
    return np.random.random() >= b

check_hit = {
    "bw": check_hit_bw,
    "heightmap": check_hit_heightmap,
}

def px_to_pos_hm(ix, iz, uv, block_width, hm_max_height, r, g, b, a=1.0):
    x, z = px_to_xz(ix, iz, uv, block_width)
    # print(f"hm b: {r}, max_h: {hm_max_height}")
    return x, hm_max_height * r, z

def px_to_pos_const(h):
    def inner(ix, iz, uv, block_width, hm_max_height, r, g, b, a=1.0):
        x, z = px_to_xz(ix, iz, uv, block_width)
        return x, h, z
    return inner

def px_to_xz(ix, iz, uv, width):
    depth = width / ix * iz
    return uv[0] * width, uv[1] * depth



px_to_pos = {
    "bw": px_to_pos_const(0),
    "heightmap": px_to_pos_hm,
}



def get_image(bs: bytes) -> Image.Image:
    return Image.open(io.BytesIO(bs))

def get_image_bs(url: str):
    if url.lower().startswith('http'):
        resp = requests.get(url)
        if resp.status_code != 200:
            raise Exception("image download url request did not have status not 200")
        return resp.content
    with open(url, 'rb') as f:
        return f.read()





def write_import_csv(data: list[list[float]], outfile: str = 'Import.csv'):
    print(f"Saving {outfile}")
    with open(outfile, 'w') as f:
        f.write("\n".join(map(sz_line, data)))
    print(f"Wrote {len(data)} spectators to out {outfile}. Done")

def sz_line(line: list[float]) -> str:
    return ",".join(map(lambda n: f"{n:.6f}", line))

def read_export_file(infile: str = 'Export.csv') -> list[list[float]]:
    """
    returns [[qx, qy, qz, qw, px, py, pz]]
    """
    ret: list[list[float]] = []
    with open(infile, 'r') as f:
        for line in f.readlines():
            ret.append(list(map(float, line.split(','))))
    print(f"Read {len(ret)} spectators")
    return ret


if __name__ == "__main__":
    cli()
